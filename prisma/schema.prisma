// prisma/schema.prisma

datasource db {
    provider = "postgresql" // or "mysql", "sqlite", etc.
    url      = env("DATABASE_URL")
}

generator client {
    provider = "prisma-client-js"
}

enum Difficulty {
    EASY
    MEDIUM
    HARD
}

model Topic {
    id       String  @id @default(uuid())
    name     String
    overview String? // High-level overview of the topic/subtopic

    parentTopicId String?
    parentTopic   Topic?  @relation("TopicHierarchy", fields: [parentTopicId], references: [id])
    subTopics     Topic[] @relation("TopicHierarchy")

    // One topic can have many cards
    cards Card[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Card {
    id                  String      @id @default(uuid())
    question            String // Flashcard question
    answer              String // Concise answer
    detailedExplanation String? // In-depth explanation
    codeSnippet         String? // Optional code snippet (for coding Q&A)
    qrCodeUrl           String? // Link to more resources or explanation
    difficulty          Difficulty? // EASY, MEDIUM, or HARD (optional)

    // Use JSON for storing multiple references (links, docs, tutorials)
    // Example usage: ["https://docs.example.com", "https://tutorial.example.com"]
    references Json?

    // Use JSON for storing contextual examples
    // Example usage: ["Example 1: ...", "Example 2: ..."]
    examples Json?

    // Relationship to Topic
    topicId String?
    topic   Topic?  @relation(fields: [topicId], references: [id])

    // Relationship to tags: many-to-many
    tags Tag[] @relation("CardToTag")

    // A card can have many revisions over time
    revisions CardRevision[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Tag {
    id   String @id @default(uuid())
    name String

    // In Prisma > 2.30, we can use "implicit many-to-many" relations.
    // We'll name the relation "CardToTag" for clarity.
    cards Card[] @relation("CardToTag")
}

// Many-to-many “implicit” relation bridging table is automatically generated by Prisma
// if you use the syntax above. If you want an explicit bridging table, you can define a model like:
// model CardTag {
//   cardId String
//   tagId  String
//   card   Card @relation(fields: [cardId], references: [id])
//   tag    Tag  @relation(fields: [tagId], references: [id])
//   @@id([cardId, tagId])
// }

/**
 * CardRevision model tracks versioning or revision history.
 * Each time you update a card, you can create a new revision record
 * to store changes in question, answer, code snippet, references, etc.
 */
model CardRevision {
    id                  String      @id @default(uuid())
    revisionNumber      Int // Increment each time the card is revised
    revisionComment     String? // Optional reason or notes (e.g., "Added more detail")
    question            String?
    answer              String?
    detailedExplanation String?
    codeSnippet         String?
    references          Json?
    examples            Json?
    difficulty          Difficulty?

    cardId String
    card   Card   @relation(fields: [cardId], references: [id])

    createdAt DateTime @default(now())
}
